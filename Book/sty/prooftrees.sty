%% prooftrees.sty - Package for typesetting natural deduction and semantic tableaux proofs
%%
%% Original Copyright 2017 Clea F. Rees
%% Modified by Jonathan Ichikawa for MIT Logic course
%% - Added 'open' marker functionality for semantic tableaux
%% - Syntax follows the 'close' marker pattern
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%%
%% DESCRIPTION:
%% This package provides a forest-based environment for typesetting
%% natural deduction proofs and semantic tableaux. It supports:
%% - Automatic line numbering with customizable formatting
%% - Justifications with cross-references to previous lines
%% - Branch closure markers for tableaux
%% - Branch opening markers for tableaux (MIT addition)
%% - Automatic vertical alignment of proof lines
%% - Highlighting of specific lines or components
%% - Support for both single-branch and grouped layouts
%%
%% KEY USER COMMANDS:
%% 
%% Environment:
%%   \begin{prooftree}[options] ... \end{prooftree}
%%   \begin{tableau}[options] ... \end{tableau}    (if tableaux option used)
%%
%% Node styles:
%%   just=text:refs          - Add justification with cross-references
%%   close                   - Mark branch as closed  
%%   close=annotation:refs   - Mark branch as closed with annotation
%%   open                    - Mark branch as open (MIT addition)
%%   open=annotation:refs    - Mark branch as open with annotation  
%%   checked, checked=name   - Mark discharged assumption
%%   subs, subs=name         - Mark universal instantiation
%%   move by=n               - Move line n positions down
%%
%% Global options:
%%   line numbering / not line numbering
%%   justifications / not justifications  
%%   single branches / not single branches
%%   zero start                - Start numbering from 0
%%   to prove=statement        - Set proof goal
%%
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{svn-prov}
\ProvidesPackageSVN{$Id: prooftrees.sty 5848 2017-02-09 02:15:38Z cfrees $}[v0.6 \revinfo]
\RequirePackage{etoolbox}

%% ===========================================
%% PACKAGE OPTIONS AND ENVIRONMENT NAMING
%% ===========================================

%% Environment name configuration
%% Default: 'prooftree' environment
%% Can be changed to 'tableau' to avoid conflicts with other packages
\newcommand*\prooftrees@enw{prooftree}

%% Package options for environment naming
\DeclareOption{tableaux}{\renewcommand*\prooftrees@enw{tableau}}
\DeclareOption{tableau}{\renewcommand*\prooftrees@enw{tableau}}
\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{forest}}

%% Automatic conflict detection with bussproofs package
%% If \prooftree is already defined, use 'tableau' as environment name
\ifundef\prooftree{\renewcommand*\prooftrees@enw{prooftree}}{\renewcommand*\prooftrees@enw{tableau}}

\ProcessOptions

%% ===========================================
%% REQUIRED PACKAGES
%% ===========================================

%% forest: Main tree-drawing engine
\RequirePackage{forest}[2016/12/04]

%% amssymb: Mathematical symbols (used for default markers)
\RequirePackage{amssymb}

%% ===========================================
%% USER-CUSTOMIZABLE COMMANDS
%% ===========================================

%% Line numbering style (default: "1.", "2.", etc.)
%% Users can redefine this command to customize line number format
\newcommand*\linenumberstyle[1]{#1.}

%% ===========================================
%% INTERNAL ARCHITECTURE NOTES
%% ===========================================
%% Keys starting with 'proof tree' are for internal use only
%% The 'proof tree' style should NOT be used directly by users
%% It is applied automatically by the prooftree environment
%% ===========================================
%% FOREST CONFIGURATION AND REGISTERS
%% ===========================================

\forestset{
  %% ===========================================
  %% USER-CONFIGURABLE BOOLEAN OPTIONS
  %% ===========================================
  
  %% Line numbering: Controls whether proof lines are numbered
  declare boolean register={line numbering},
  line numbering,  % Default: enabled
  
  %% Justifications: Controls whether justifications appear on the right
  declare boolean register={justifications},
  not justifications,  % Default: disabled (no point unless user provides content)
  
  %% Single branches: Controls branch drawing behavior
  %% - true: explicit branches with normal spacing between single children and parents
  %% - false: single children are grouped with their parents (more compact)
  declare boolean register={single branches},
  not single branches,  % Default: group single children with parents
  
  %% ===========================================
  %% SPACING AND LAYOUT DIMENSIONS
  %% ===========================================
  
  %% Width reserved for line numbers (auto-calculated from "99.")
  declare dimen register={line no width},
  line no width'=0pt,  % Fallback default
  
  %% Distance between main tree and justifications
  declare dimen register={just sep},
  just sep'=1.5em,
  
  %% Distance between main tree and line numbers
  declare dimen register={line no sep},
  line no sep'=1.5em,
  
  %% Distance between closure/opening symbols and following annotations
  declare dimen register={close sep},
  close sep'=.75\baselineskip,
  %% ===========================================
  %% INTERNAL POSITIONING COORDINATES
  %% ===========================================
  
  %% X-coordinates for line numbers and justifications (calculated internally)
  declare dimen register={proof tree line no x},
  proof tree line no x'=0pt,
  declare dimen register={proof tree justification x},
  proof tree justification x'=0pt,
  
  %% ===========================================
  %% INTERNAL COUNTERS
  %% ===========================================
  
  %% Count proof tree levels
  declare count register={proof tree rhif lefelau},
  proof tree rhif lefelau'=0,
  
  %% Count line numbers (left side)
  declare count register={proof tree lcount},
  proof tree lcount'=0,
  
  %% Count justifications (right side)
  declare count register={proof tree jcount},
  proof tree jcount'=0,
  
  %% Line numbering adjustment (for zero-start numbering, etc.)
  declare count register={line no shift},
  line no shift'=0,
  
  %% Internal processing counter
  declare count register={proof tree aros},
  proof tree aros'=0,
  
  %% ===========================================
  %% SYMBOL CONFIGURATION
  %% ===========================================
  
  %% Checked/discharged formula marker (for existential instantiation)
  declare toks register={check with},
  check with={\ensuremath{\checkmark}},
  declare boolean register={check right},
  check right,  % Default: marker appears on right side
  check left/.style={not check right},
  
  %% Substitution marker (for universal instantiation)
  declare toks register={subs with},
  subs with={\ensuremath{\backslash}},
  declare boolean register={subs right},
  subs right,  % Default: marker appears on right side
  subs left/.style={not subs right},
  
  %% Branch closure marker (semantic tableaux)
  declare toks register={close with},
  close with={\ensuremath{\otimes}},
  
  %% Branch opening marker (MIT addition for semantic tableaux)
  declare toks register={open with},
  open with={\ensuremath{\uparrow}},
  
  %% Delimiter for merging conflicting justifications
  declare toks register={merge delimiter},
  merge delimiter={\text{; }},
  
  %% ===========================================
  %% FORMATTING OPTIONS
  %% ===========================================
  
  %% Closure annotation formatting
  declare keylist register={close format},
  close format={font=\scriptsize},
  declare keylist register={close with format},
  close with format={},
  
  %% Justification placement and formatting
  declare boolean register={just refs left},
  just refs left,  % Default: reference numbers appear on left side of justification
  just refs right/.style={not just refs left},
  declare keylist register={just format},
  just format={},
  
  %% Line number formatting
  declare keylist register={line no format},
  line no format={},
  
  %% Highlighting format (for emphasized lines/components)
  declare autowrapped toks register={highlight format},
  highlight format={draw=gray, rounded corners},
  
  %% Proof statement formatting (top of proof)
  declare keylist register={proof statement format},
  proof statement format={},
  
  %% Well-formed formula formatting
  declare keylist register={wff format},
  wff format={},
  %% ===========================================
  %% INTERNAL NODE TYPE FLAGS
  %% ===========================================
  
  %% Marks nodes that contain justifications
  declare boolean={proof tree justification}{0},
  
  %% Marks nodes that contain line numbers
  declare boolean={proof tree line number}{0},
  
  %% Marks nodes that should be grouped with their parents (compact layout)
  declare boolean={grouped}{0},
  
  %% Marks phantom nodes (used for structural purposes, not displayed)
  declare boolean={proof tree phantom}{0},
  
  %% ===========================================
  %% HIGHLIGHTING FLAGS
  %% ===========================================
  
  %% Individual component highlighting
  declare boolean={highlight wff}{0},        % Highlight well-formed formulas
  declare boolean={highlight just}{0},       % Highlight justifications
  declare boolean={highlight line no}{0},    % Highlight line numbers
  declare boolean={highlight line}{0},       % Highlight entire proof lines
  
  %% Auto-forwarding: when "highlight line" is used, automatically enable all components
  Autoforward={highlight line}{highlight just, highlight wff, highlight line no},
  %% ===========================================
  %% INTERNAL STRUCTURAL FLAGS
  %% ===========================================
  
  %% Movement and positioning flags (used for complex tree rearrangement)
  declare boolean={proof tree toing}{0},           % Mark nodes to be moved
  declare boolean={proof tree toing with}{0},      % Mark nodes moving with parents
  declare boolean={proof tree rhiant cymysg}{0},   % Mark parents with mixed children
  declare boolean={proof tree rhifo}{1},           % Include in proof line numbering
  declare boolean={proof tree arweinydd}{0},       % Mark lead nodes for movements
  
  %% ===========================================
  %% CONTENT STORAGE
  %% ===========================================
  
  %% Justification content and cross-references
  declare autowrapped toks={just}{},                              % Justification text
  declare toks={proof tree rhestr rhifau llinellau}{},           % Line number list for justifications
  declare toks={proof tree rhestr rhifau llinellau cau}{},       % Line number list for closures
  
  %% Closure and opening markers with annotations
  declare toks={proof tree close}{},               % Closure annotation content
  declare toks={proof tree open}{},                % Opening annotation content
  
  %% ===========================================
  %% FORMATTING OPTIONS STORAGE
  %% ===========================================
  
  %% TikZ options for different components
  declare autowrapped toks={just options}{},       % TikZ options for justifications
  declare autowrapped toks={line no options}{},    % TikZ options for line numbers
  declare autowrapped toks={wff options}{},         % TikZ options for formulas
  declare autowrapped toks={line options}{},        % TikZ options for entire lines
  
  %% Auto-forwarding: line options apply to all components
  Autoforward={line options}{just options={#1}, line no options={#1}, wff options={#1}},
  
  %% ===========================================
  %% MOVEMENT AND POSITIONING COUNTERS
  %% ===========================================
  
  declare count={proof tree toing by}{0},          % How many lines to move by
  declare count={proof tree cadw toing by}{0},     % Saved movement amount
  declare count={proof tree toooing}{0},           % Movement processing counter
  declare count={proof tree proof line no}{0},     % Current proof line number
  
  %% ===========================================
  %% INTERNAL DATA STRUCTURES
  %% ===========================================
  
  %% Cross-reference storage
  declare keylist={proof tree jrefs}{},            % Justification cross-references
  declare keylist={proof tree crefs}{},            % Closure cross-references
  
  %% Processing stage keylists (control the order of operations)
  declare keylist={proof tree ffurf}{},            % Form/structure processing
  declare keylist={proof tree symud awto}{},       % Automatic movement processing
  declare keylist={proof tree creu nodiadau}{},    % Create annotations
  declare keylist={proof tree nodiadau}{},         % Process annotations
  %% ===========================================
  %% INTERNAL PROCESSING STEPS
  %% ===========================================
  %% These define the order and method of tree processing
  
  %% Basic tree sorting by level and children count
  define long step={proof tree symud}{}{%
    root,sort by={>{O}{level},>{_O<}{1}{n children}},sort'=descendants
  },
  
  %% Corrected movement sorting (accounts for line numbering)
  define long step={proof tree cywiro symud}{}{%
    root,if line numbering={n=2}{n=1},sort by={>{O}{level},>{_O<}{1}{n children}},sort'=descendants
  },
  
  %% Y-coordinate based sorting for final positioning
  %% Filters out phantom nodes that shouldn't be numbered
  define long step={proof tree camau}{}{%
    root,sort by={>{O}{y},>{Ow1+d}{x}{-##1}},sort'={filter={descendants}{>{OO!&}{proof tree rhifo}{proof tree phantom}}}
  },
  
  %% Process only the main tree (after annotations are created)
  define long step={proof tree wffs}{}{%
    fake=root,if line numbering={n=2}{n=1},tree
  },
  
  %% ===========================================
  %% USER-FACING STYLES AND COMMANDS
  %% ===========================================
  %% Mark formula as checked/discharged (existential instantiation)
  %% Usage: checked, checked=name
  %% Adds checkmark symbol with optional name substitution
  checked/.style={%
    delay={%
      if check right={%
        content+'={\ \forestregister{check with}#1},
      }{%
        +content'={\forestregister{check with}#1\ },
      },
    },
  },
  
  %% Mark formula with substitution (universal instantiation)
  %% Usage: subs, subs=name  
  %% Adds backslash symbol with optional name substitution
  subs/.style={%
    delay={%
      if subs right={%
        content+'={\ \forestregister{subs with}#1},
      }{%
        +content'={\forestregister{subs with}#1\ },
      },
    },
  },
  %% ===========================================
  %% BRANCH CLOSURE AND OPENING MARKERS
  %% ===========================================
  
  %% Mark a tableau branch as closed
  %% Usage: close, close=annotation, close=annotation:ref1,ref2
  %% Creates nodes for the closure symbol and optional annotation
  %% Must be processed before tree packing for proper spacing
  close/.style={%
    if={%
      >{__=}{#1}{}%
    }{}{%
      temptoksb={},
      temptoksa={#1},
      split register={temptoksa}{:}{proof tree close,temptoksb},
      if temptoksb={}{}{%
        split register={temptoksb}{,}{proof tree cref},
      },
    },
    delay={%
      append={% this node holds the closure symbol
        [\forestregister{close with},
          not proof tree rhifo,
          proof tree phantom,
          grouped,
          no edge,
          process keylist register=close with format,
          before computing xy={% adjust the distance between the closure symbol and any annotation
            delay={%
              for children={%
                l/.register=close sep,
              },
            },
          },
          before drawing tree={%
            if={>{RR|}{line numbering}{justifications}}{%
              proof tree proof line no/.option=!parent.proof tree proof line no,
            }{},
          },
          if={%
            >{__=}{#1}{}%
          }{}{% don't create a second node if there's no annotation
            delay={%
              append={% this node holds the annotation, possibly including cross-references which will be relative to the node's grandparent
                [,
                  not proof tree rhifo,
                  proof tree phantom,
                  grouped,
                  no edge,
                  process keylist register=close format,
                  if={%
                    >{O_=}{!parent,parent.proof tree close}{}%
                  }{}{content/.option=!{parent,parent}.proof tree close},
                  proof tree crefs/.option=!{parent,parent}.proof tree crefs,
                  delay={%
                    !{parent,parent}.proof tree crefs'={},
                  },
                  before drawing tree={%
                    if={>{RR|}{line numbering}{justifications}}{%
                      proof tree proof line no/.option=!{parent,parent}.proof tree proof line no,
                    }{},
                  },
                ]%
              },
            },
          },
        ]%
      },
    },
  },
  %% Mark a tableau branch as open (MIT addition)
  %% Usage: open, open=annotation, open=annotation:ref1,ref2  
  %% Syntax mirrors the 'close' command but uses different symbol
  %% Creates nodes for the opening symbol and optional annotation
  open/.style={%
    if={%
      >{__=}{#1}{}%
    }{}{%
      temptoksb={},
      temptoksa={#1},
      split register={temptoksa}{:}{proof tree close,temptoksb},
      if temptoksb={}{}{%
        split register={temptoksb}{,}{proof tree cref},
      },
    },
    delay={%
      append={% this node holds the open symbol
        [\forestregister{open with},
          not proof tree rhifo,
          proof tree phantom,
          grouped,
          no edge,
          process keylist register=close with format,
          before computing xy={% adjust the distance between the closure symbol and any annotation
            delay={%
              for children={%
                l/.register=close sep,
              },
            },
          },
          before drawing tree={%
            if={>{RR|}{line numbering}{justifications}}{%
              proof tree proof line no/.option=!parent.proof tree proof line no,
            }{},
          },
          if={%
            >{__=}{#1}{}%
          }{}{% don't create a second node if there's no annotation
            delay={%
              append={% this node holds the annotation, possibly including cross-references which will be relative to the node's grandparent
                [,
                  not proof tree rhifo,
                  proof tree phantom,
                  grouped,
                  no edge,
                  process keylist register=close format,
                  if={%
                    >{O_=}{!parent,parent.proof tree close}{}%
                  }{}{content/.option=!{parent,parent}.proof tree close},
                  proof tree crefs/.option=!{parent,parent}.proof tree crefs,
                  delay={%
                    !{parent,parent}.proof tree crefs'={},
                  },
                  before drawing tree={%
                    if={>{RR|}{line numbering}{justifications}}{%
                      proof tree proof line no/.option=!{parent,parent}.proof tree proof line no,
                    }{},
                  },
                ]%
              },
            },
          },
        ]%
      },
    },
  },
  %% ===========================================
  %% LINE NUMBER CREATION AND MANAGEMENT
  %% ===========================================
  
  %% Create line numbers on the left side of proofs
  %% Line numbers must be part of the tree structure for proper positioning
  %% Each line number becomes child of the previous one during processing
  proof tree line no/.style={%
    anchor=base west,
    no edge,
    proof tree line number,
    text width/.register=line no width,
    x'/.register=proof tree line no x,
    process keylist register=line no format,
    delay={%
      proof tree lcount'+=1,
      tempcounta/.process={RRw2+n}{proof tree lcount}{line no shift}{##1+##2},
      content/.process={Rw1}{tempcounta}{\linenumberstyle{##1}},% content i.e. the line number
      name/.expanded={line no \foresteregister{tempcounta}},% name them so they can be moved later
      typeset node,
      if proof tree lcount>=3{% the initial location of most line numbers is incorrect and they must be moved
        for previous={% move the line number below the previous line number
          append/.expanded={line no \foresteregister{tempcounta}}
        },
      }{},
    },
  },
  %% ===========================================
  %% JUSTIFICATION CREATION AND MANAGEMENT  
  %% ===========================================
  
  %% Create justification nodes on the right side of proofs
  %% Content is added later during annotation processing
  proof tree line justification/.style={%
    anchor=base west,
    no edge,
    proof tree justification,
    x'/.register=proof tree justification x,
    process keylist register=just format,
    delay={%
      proof tree jcount'+=1,
      tempcounta/.process={RRw2+n}{proof tree jcount}{line no shift}{##1+##2},
      name/.expanded={just \foresteregister{tempcounta}},% name them so they can be moved
      typeset node,% angen i osgoi broblemau 'da highlight just/line etc.
      if proof tree jcount>=3{% correct the location as for the line numbers (cf. line no style)
        for previous={%
          append/.expanded={just \foresteregister{tempcounta}},
        },
      }{},
    },
  },
  %% ===========================================
  %% PROOF CONFIGURATION OPTIONS
  %% ===========================================
  
  %% Start line numbering from 0 instead of 1
  zero start/.style={%
    line no shift'+=-1,
  },
  
  %% Set the statement to be proved (appears at top)
  %% Usage: to prove=statement
  to prove/.style={%
    for root={%
      before typesetting nodes={%
        content={#1},
        phantom=false,
        baseline,
        if line numbering={anchor=base west}{anchor=base},
        process keylist register=proof statement format
      },
      before computing xy={%
        delay={%
          for children={%
            l=1.5*\baselineskip,
          },
        },
      },
    },
  },
  %% ===========================================
  %% MAIN PROOF TREE STYLE (INTERNAL USE ONLY)
  %% ===========================================
  %% This style configures the entire proof tree structure
  %% **DO NOT USE DIRECTLY** - Applied automatically by prooftree environment
  proof tree/.style={%
    for tree={%
      parent anchor=children,% manual 64
      child anchor=parent,% manual 64
      math content,
      delay={%
        if just={}{}{% if we've got justifications, make sure nodes are created for them later and split out cross-references so we identify the correct nodes before anything gets moved, allowing the use of relative node names
          justifications,
          temptoksa={},
          split option={just}{:}{just,temptoksa},
          if temptoksa={}{}{%
            split register={temptoksa}{,}{proof tree jref},
          },
        },
        if content={}{% if there's no proof statement
          if level=0{}{%
            shape=coordinate,
          },
        }{},
      },
    },
    where level=0{%
      for children={% no edges from phantom root or proof statement to children
        before typesetting nodes={%
          no edge,
        },
      },
      delay={%
        if content={}{phantom}{},
        if line numbering={% create the line numbers if appropriate
          parent anchor=south west,
          if line no width={0pt}{%
            line no width/.pgfmath={width("\noexpand\linenumberstyle{99}")},
          }{},
        }{},
      },
      proof tree creu nodiadau={% this is processed after computing xy
        if={>{RR|}{line numbering}{justifications}}{% count proof lines if necessary
          proof tree rhif lefelau'/.register=line no shift,
          for proof tree camau={%
            if level>=1{%
              if={%
                >{OO<}{y}{!back.y}%
              }{%
                proof tree rhif lefelau'+=1,
                proof tree proof line no'/.register=proof tree rhif lefelau,
              }{%
                proof tree proof line no'/.register=proof tree rhif lefelau
              },
            }{},
          },
        }{},
        if line numbering={% get the x position of line numbers and adjust the location and alignment of the proof statement
          proof tree line no x/.min={>{OOw2+d}{x}{min x}{##1+##2}}{fake=root,descendants},
          proof tree line no x-/.register=line no width,
          proof tree line no x-/.register=line no sep,
          for root={%
            tempdimc/.option=x,
            x'+/.register=proof tree line no x,
            x'-/.option=min x,
          },
          prepend={% create line numbers on left
            [,
              proof tree line no,
              % () to group are required here - otherwise, the -1 (or -2 or whatever) is silently ignored
              repeat={((proof_tree_rhif_lefelau)-1)-(line_no_shift)}{% most are created in the wrong place but proof tree line no moves them later
                delay n={proof_tree_lcount}{
                  append={[, proof tree line no]},
                },
              },
            ]%
          },
        }{},
        if justifications={% get the x position of justifications and create the nodes which will hold the justification content, if required
          proof tree justification x/.max={>{OOw2+d}{x}{max x}{##1+##2}}{fake=root,descendants},
          proof tree justification x+/.register=just sep,
          append={%
            [,
              proof tree line justification,
              repeat={((proof_tree_rhif_lefelau)-1)-(line_no_shift)}{% most are created in the wrong place but proof tree line justification moves them later
                delay n={proof_tree_jcount}{%
                  append={[, proof tree line justification]},
                },
              }%
            ]%
          },
        }{},
      },
    }{%
      delay={%
        if single branches={}{% automatically group lines if not using single branches
          if n children=1{%
            for children={%
              grouped,
            },
          }{},
        },
      },
      before typesetting nodes={% apply wff-specific highlighting and additional TikZ keys
        process keylist register=wff format,
        if highlight wff={node options/.register=highlight format}{},
        node options/.option=wff options,
      },
    },
    proof tree ffurf={% processed before proof tree symud auto: adjusts the alignment of lines when some levels of the tree are grouped together either whenever the number of children is only 1 or by applying the grouped style to particular nodes when specifying the tree
      if single branches={%
        where={%
          >{O! _O< O &&}{grouped}{2}{level}{proof tree rhifo}%
        }{%
          if={%
           >{_O= _O< &}{1}{!parent.n children}{1}{!parent,parent.n children}%
          }{%
            not tempboola,
            for root/.process={Ow1}{level}{%
              for level={##1}{%
                if={%
                 >{_O< _O= &}{1}{!parent.n children}{1}{n}%
                }{%
                  tempboola,
                }{},
              },
            },
            if tempboola={%
              proof tree toing,
            }{},
          }{},
        }{},
      }{},
      where={%
       >{O _O< O &&}{grouped}{1}{level}{proof tree rhifo}%
      }{% this searches for certain kinds of structural asymmetry in the tree and attempts to move lines appropriately in such cases - the algorithm is intended to be relatively conservative (not in the sense of 'cautious' or 'safe' but in the sense of 'reflection of the overlapping consensus of reasonable users' / 'what would be rationally agreed behind the prooftrees veil of ignorance'; apologies for the inconvenience if you are an unreasonable user)
        not tempboola,
        for root/.process={Ow1}{level}{%
          for level={##1}{%
            if={%
             >{_O< _O= &}{1}{!parent.n children}{1}{n}%
            }{%
              tempboola,
            }{},
          },
        },% Sašo:  http://chat.stackexchange.com/transcript/message/27874731#27874731, see also http://chat.stackexchange.com/transcript/message/27874722#27874722
        if tempboola={%
          if n children=0{%
            if={>{OO|}{!parent.proof tree toing}{!parent.proof tree toing with}}{% we're already moving the parent and the child will move with the parent, so we can just mark this and do nothing else
              proof tree toing with,
            }{%
              for root/.process={Ow1}{level}{% don't move a terminal node even in case of asymmetry: instead, create a separate proof line for terminal nodes on this level which are only children, by moving children with siblings on this level down a proof line, without altering their physical location
                % this makes the tree more compact and stops it looking silly
                for level={##1}{%
                  if={%
                   >{_O< _O= &}{1}{!parent.n children}{1}{n}%
                  }{% this just serves to keep the levels nice for the sub-tree and ensure things align. We need this because we want to skip a level here to allow room for the terminal node in the other branch
                    for parent={%
                      if proof tree rhiant cymysg={}{% we mark the parent to avoid increasing the line number of its descendants more than once
                        proof tree rhiant cymysg,
                        for descendants={%
                          proof tree toing by'+=1,
                        },
                      },
                    },
                  }{},
                },
              },% Sašo:  http://chat.stackexchange.com/transcript/message/27874731#27874731, see also http://chat.stackexchange.com/transcript/message/27874722#27874722
            },
            no edge,
          }{%
            if={%
             >{_O= _O< &}{1}{!parent.n children}{1}{!parent,parent.n children}%
            }{% don't try to move if the node has more than 1 child or the grandparent has no more than that; otherwise, mark the node as one to move - we figure out where to move it later
              proof tree toing,
            }{no edge},
          },
        }{no edge},
      }{},
    },
    proof tree symud awto={% processed before typesetting nodes: if _this_ could be done during packing, that would be very nice, even if the previous stuff can't be
      proof tree aros'=0,
      for proof tree symud={%
        if proof tree toing={% this relies on an experimental feature of forest, which is anffodus
          for nodewalk={fake=parent,fake=sibling,descendants}{do dynamics},
          delay n={\foresteregister{proof tree aros}}{%
            tempcounta/.max={>{OOOOw4+n}{level}{proof tree toing by}{proof tree toooing}{proof tree rhifo}{(##1+##2+##3)*##4}}{parent,sibling,descendants},
            if tempcounta>=1{%
              if={%
               >{Rw1+n OOw2+n >}{tempcounta}{##1+1}{level}{proof tree toing by}{##1+##2}%
              }{%
                tempcounta-/.option=level,
                tempcounta'+=1,
                move by/.register=tempcounta,
              }{no edge},
            }{no edge},
          },
          proof tree aros'+=4,
        }{},
      },
    },
    proof tree nodiadau={% processed after proof tree creu nodiadau and before before drawing tree: creates annotation content which may include cross-references, applies highlighting and additional TikZ keys to line numbers, justifications and to wffs where specified for entire proof lines
      where proof tree crefs={}{}{% resolve cross-refs in closures
        split option={proof tree crefs}{,}{proof tree rhif llinell cau},
        if content={}{%
          content/.option=proof tree rhestr rhifau llinellau cau,
        }{%
          content+/.process={_O}{\ }{proof tree rhestr rhifau llinellau cau},
        },
        typeset node,
      },
      if line numbering={% apply highlighting and additional TikZ keys to line numbers; initial alignment of numbers with proof lines
        for proof tree wffs={%
          if highlight line no={%
            for name/.process={Ow1OOOw3}{proof tree proof line no}{line no ##1}{proof tree proof line no}{line no options}{y}{% from Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?!
              node options/.register=highlight format,
              ##2,
              y'=##3,
              proof tree proof line no'=##1,
              typeset node,
            }%
          }{%
            if line no options={}{%
              if proof tree phantom={}{%
                for name/.process={Ow1OOw2}{proof tree proof line no}{line no ##1}{proof tree proof line no}{y}{%
                  y'=##2,
                  proof tree proof line no'=##1,
                }%
              },
            }{%
              for name/.process={Ow1OOOw3}{proof tree proof line no}{line no ##1}{proof tree proof line no}{line no options}{y}{%
                ##2,
                y'=##3,
                proof tree proof line no'=##1,
                typeset node,
              }%
            },
          },
        },
      }{},
      if justifications={% initial alignment of justifications with proof lines, addition of content, resolution of cross-references and application of highlighting and additional TikZ keys
        for proof tree wffs={%
          if just={}{%
            if proof tree phantom={}{%
              for name/.process={Ow1OOw2}{proof tree proof line no}{just ##1}{proof tree proof line no}{y}{% from Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?!
                y'=##2,
                proof tree proof line no'=##1,
              }%
            },
          }{% puts the content of the justifications into the empty justification nodes on the right; because this is done late, the nodes need to be typeset again
            if proof tree jrefs={}{}{% resolve cross-refs in justifications
              split option={proof tree jrefs}{,}{proof tree rhif llinell},
              if just refs left={%
                +just/.process={O_}{proof tree rhestr rhifau llinellau}{\ },
              }{%
                just+/.process={_O}{\ }{proof tree rhestr rhifau llinellau},
              },
            },
            if highlight just={% apply highlighting and additional TikZ keys to justifications, set content and merge any conflicting specifications, warning user if appropriate
              for name/.process={Ow1OOOOw4}{proof tree proof line no}{just ##1}{proof tree proof line no}{just}{just options}{y}{% from Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?!
                if={%
                 >{O_= O_= |}{content}{}{content}{##2}%
                }{% gweler isod - o gôd Sašo
                  content={##2},
                }{%
                  content+'={\foresteregister{merge delimiter}##2},
                  TeX={\PackageWarning{prooftrees}{Merging conflicting justifications for line ##1! Please examine the output carefully and use "move by" to move lines later in the proof if required. Details of how to do this are included in the documentation.}},
                },
                node options/.register=highlight format,
                ##3,
                y'=##4,
                proof tree proof line no'=##1,
                typeset node,
              }% do NOT put a comma here!
            }{%
              for name/.process={Ow1OOOOw4}{proof tree proof line no}{just ##1}{proof tree proof line no}{just}{just options}{y}{% from Sašo's anti-pgfmath version - rhaid ddweud proof tree proof line no yn ddwywaith ?! dim yn bosibl i ailddefnyddio'r gyntaf ?!
                if={% from Sašo's anti-pgfmath version - I appreciate this is faster, but why is it *required*?!
                 >{O_= O_= |}{content}{}{content}{##2}%
                }{%
                  content={##2},
                }{%
                  content+'={\foresteregister{merge delimiter}##2},
                  TeX={\PackageWarning{prooftrees}{Merging conflicting justifications for line ##1! Please examine the output carefully and use "move by" to move lines later in the proof if required. Details of how to do this are included in the documentation.}},
                },
                ##3,
                y'=##4,
                proof tree proof line no'=##1,
                typeset node,
              }% do NOT put a comma here!
            }
          },
        },
      }{},
      for proof tree wffs={% apply highlighting and TikZ keys which are specified for whole proof lines to all applicable wffs
        if proof tree phantom={}{%
          if highlight line={%
            for proof tree wffs/.process={OOw2}{proof tree proof line no}{line options}{%
              if proof tree proof line no={##1}{%
                node options/.register=highlight format,
                ##2,
              }{}%
            },
          }{%
            for proof tree wffs/.process={OOw2}{proof tree proof line no}{line options}{%
              if proof tree proof line no={##1}{##2}{},
            },
          },
          delay={typeset node},
        },
      },
    },
    before packing={% initial alignment so we don't get proof line numbers incrementing due to varying height/depth of nodes, for example - when single branches is true and few nodes are grouped, this is also a reasonable first approximation
      for tree={%
        tier/.process={OOw2+nw1}{level}{proof tree toing by}{##1+##2}{tier ##1},
      },
      for root={% if there's no proof statement, adjust the alignment of the proof relative to the surrounding text
        if content={}{%
          !{n=1}.baseline,
        }{},
      },
    },
    before computing xy={% adjust distance between levels for grouped nodes after tree is packed
      for tree={%
        if={%
         >{O _O< &}{grouped}{1}{level}%
        }{l'=\baselineskip}{},
      },
    },
    before drawing tree={% set final alignment for proof lines which have been moved by effectively grouping lead nodes and moving their subtrees accordingly - this requires that each line number and justification be the child of the previous one and that if justifications are used at all, then justifications exist for all proof lines, even if empty
      if={>{RR|R!&}{line numbering}{justifications}{single branches}}{% correct the alignment of move by lines when single branches is false - o fersiwn anti-pgfmath Sašo
        tempdimc'=0pt,% track cumulative adjustments to line numbers and justifications
        for proof tree cywiro symud={%
          if proof tree arweinydd={% only examine the lead nodes - their descendants need the same (cumulative) adjustments
            tempdima'/.option=y,
            if line numbering={% if there are line numbers, we use the previous line number's vertical position
              for name/.process={Ow1+nw1}{proof tree proof line no}{##1-1}{line no ##1}{% arafach ?
                tempdimb'/.option=y,
              }%
            }{% if not, we use the previous justification's vertical position
              for name/.process={Ow1+nw1}{proof tree proof line no}{##1-1}{just ##1}{% arafach ?
                tempdimb'/.option=y,
              }%
            },
            for parent={% the parent (which will be a phantom) gets aligned with the previous line
              y'/.register=tempdimb,
            },
            if tempdimb<={0pt}{% adjust so we align this line below the previous one (assuming we're going down)
              tempdimb'-=\baselineskip,
            }{%
              tempdimb'+=\baselineskip,
            },
            tempdimb'-/.register=tempdima,% how far are we moving?
            for tree={% adjust this node and all descendants
              y'+/.register=tempdimb,
            },
            tempdimb'-/.register=tempdimc,% deduct any tracked cumulative adjustments to line numbers and justifications
            if line numbering={% adjust the line numbers, if any
              for name/.process={Ow1}{proof tree proof line no}{line no ##1}{%
                for tree={%
                  y'+/.register=tempdimb,
                },
              }%
            }{},
            if justifications={% adjust the justifications, if any
              for name/.process={Ow1}{proof tree proof line no}{just ##1}{% t. 60 manual 2.1 rc1
                for tree={%
                  y'+/.register=tempdimb,
                },
              }%
            }{},
            tempdimc'/.register=tempdimb,% add the adjustment just implemented to the tracked cumulative adjustments for line numbers and/or justifications
          }{},
        },
      }{},
    },
  },
  %% ===========================================
  %% LINE MOVEMENT SYSTEM
  %% ===========================================
  
  %% Move a proof line down by a specified number of positions
  %% Usage: move by=n
  %% Implements both automatic and user-requested movements
  %% May be adjusted later to avoid gaps in numbering
  move by/.style={%
    if={
     >{_n<}{0}{#1}%
    }{% only try to move the node if the target line number exceeds the one i.e. the line number is to be positively incremented
      proof tree cadw toing by/.option=proof tree toing by,
      proof tree arweinydd,
      for tree={%
        if={%
         >{_n<}{1}{#1}%
        }{% track skipped lines for which we won't be creating phantom nodes
          proof tree toing by+=#1-2,
          proof tree toooing'+=1,
        }{},
      },
      delay={%
        replace by={% insert our first phantom
          [,
            if={%
             >{_n<}{1}{#1}%
            }{%
              child anchor=parent,
              parent anchor=parent,
            }{%
              child anchor=children,
              parent anchor=children,
            },
            proof tree phantom,
            edge path/.option=!last dynamic node.edge path,% Sašo Živanović: http://chat.stackexchange.com/transcript/message/27990955#27990955
            edge/.option=!last dynamic node.edge,
            append,
            before drawing tree={%
              if={>{RR|}{line numbering}{justifications}}{%
                proof tree proof line no/.process={Ow1+n}{!parent.proof tree proof line no}{##1+1},
              }{},
            },
            if={%
             >{_n<}{1}{#1}%
            }{% if we are moving by more than 1, we insert a second phantom so that a node with siblings which is moved a long way will not get a unidirectional edge but an edge which looks similar to others in the tree (by default, sloping down a line or so and then plummeting straight down rather than a sharply-angled steep descent)
              delay={%
                append={%
                  [,
                    child anchor=parent,
                    parent anchor=parent,
                    proof tree toing by=#1-2+proof_tree_cadw_toing_by,
                    proof tree phantom,
                    edge path/.option=!last dynamic node.edge path,
                    edge/.option=!last dynamic node.edge,
                    before drawing tree={%
                      if={>{RR|}{line numbering}{justifications}}{%
                        proof tree proof line no/.process={Ow1+n}{!n=1.proof tree proof line no}{##1-1},
                      }{},
                    },
                    append=!sibling,
                  ]%
                },
              },
            }{%
              if single branches={}{%
                delay={%
                  for children={%
                    no edge,
                  },
                },
              },
            },
           ]%
        },
      },
    }{%
      TeX/.process={Ow1}{name}{\PackageWarning{prooftrees}{Line not moved! I can only move things later in the proof. Please see the documentation for details. ##1}},
    },
  },
  proof tree cref/.style={% get the names of nodes cross-referenced in closure annotations for use later
    proof tree crefs+/.option=#1.name,
  },
  proof tree rhif llinell cau/.style={% get the proof line numbers of the cross-referenced nodes in closure annotations, using the list of names created earlier
    if proof tree rhestr rhifau llinellau cau={}{}{%
      proof tree rhestr rhifau llinellau cau+={,\,},
    },
    proof tree rhestr rhifau llinellau cau+/.option=#1.proof tree proof line no,
  },
  proof tree jref/.style={% get the names of nodes cross-referenced in justifications for use later
    proof tree jrefs+/.option=#1.name,
  },
  proof tree rhif llinell/.style={% get the proof line numbers of the cross-referenced nodes in justifications, using the list of names created earlier
    if proof tree rhestr rhifau llinellau={}{}{%
      proof tree rhestr rhifau llinellau+={,\,},
    },
    proof tree rhestr rhifau llinellau+/.option=#1.proof tree proof line no,% works according to Sašo's anti-pgfmath version
  },
  proof tree dadfygio/.style={% style for use in debugging moves which displays information about nodes in the tree
    before packing={%
      for tree={%
        label/.process={OOOw3}{level}{proof tree toing by}{id}{[red,font=\tiny,inner sep=0pt,outer sep=0pt, anchor=south]below:##1/##2/##3},
      },
    },
    before drawing tree={%
      for tree={%
        delay={%
          tikz+/.process={Ow1}{proof tree proof line no}{\node [anchor=west, font=\tiny, text=blue, inner sep=0pt] at (.east) {##1}; },
        },
      },
    },
  },
}

%% ===========================================
%% ENVIRONMENT DEFINITION
%% ===========================================

%% Set up environment body capture
\environbodyname\prooftreebody
\bracketset{action character=@}

%% Define the main prooftree environment
%% Takes optional arguments for forest configuration
\NewEnviron{\prooftrees@enw}[1]{%
  \forest
    (%
      stages={%
        %% Standard forest processing stages with custom additions
        for root'={%
          process keylist register=default preamble,
          process keylist register=preamble,
        },
        process keylist=given options,
        process keylist=before typesetting nodes,
        
        %% CUSTOM STAGES: Structure and movement processing
        process keylist=proof tree ffurf,        % Form/structure processing
        process keylist=proof tree symud awto,   % Automatic movement processing
        
        typeset nodes stage,
        process keylist=before packing,
        pack stage,
        process keylist=before computing xy,
        compute xy stage,
        
        %% CUSTOM STAGES: Annotation processing  
        process keylist=proof tree creu nodiadau, % Create annotations
        process keylist=proof tree nodiadau,       % Process annotations
        
        process keylist=before drawing tree,
        draw tree stage,
      },
    )%
    proof tree,  %% Apply main proof tree configuration
    #1,          %% User's optional configuration
    [, name=proof statement @\prooftreebody]%  %% Insert proof content
  \endforest}
\endinput
%% end prooftrees.sty
